<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Truth Serum — Decentralized Fact Checker</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;max-width:980px;margin:28px auto;padding:0 16px}
    .card{border:1px solid #ddd;border-radius:14px;padding:14px;margin-top:14px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    input,textarea{width:100%;padding:10px 12px;font-size:15px;border:1px solid #ddd;border-radius:10px}
    button{padding:10px 14px;font-size:15px;cursor:pointer;border-radius:10px;border:1px solid #ddd;background:#fff}
    .muted{color:#666;font-size:13px}
    .pill{display:inline-block;padding:4px 10px;border:1px solid #ddd;border-radius:999px;font-size:13px}
    pre{white-space:pre-wrap;word-break:break-word;background:#fafafa;border:1px solid #eee;padding:12px;border-radius:12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width: 860px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <h1>Truth Serum</h1>
  <p class="muted">
    Paste a link → on-chain fact check → verdict + explanation + sources.
  </p>

  <div class="card">
    <div class="row">
      <button id="btnConnect">Connect MetaMask</button>
      <span id="wallet" class="muted">Not connected</span>
      <span class="pill" id="chain">Chain: —</span>
    </div>

    <label class="muted" style="display:block;margin-top:12px;">URL</label>
    <input id="url" placeholder="https://..." />

    <div class="row" style="margin-top:12px;">
      <button id="btnVerify">Verify (on-chain)</button>
      <button id="btnGet">Get(url)</button>
      <button id="btnLast">Get last</button>
    </div>

    <div class="muted" id="status" style="margin-top:10px;">—</div>

    <label class="muted" style="display:block;margin-top:12px;">Tx hash</label>
    <input id="txhash" placeholder="0x..." />
  </div>

  <div class="card" id="out" style="display:none;">
    <div class="row" style="justify-content:space-between;">
      <span class="pill" id="verdict">Verdict: —</span>
      <span class="muted" id="txline">—</span>
    </div>

    <h3>Explanation</h3>
    <div id="explanation" class="muted">—</div>

    <h3>Sources</h3>
    <div id="sources" class="muted">—</div>

    <h3>Key claims</h3>
    <div id="claims" class="muted">—</div>

    <details style="margin-top:10px;">
      <summary>Raw JSON</summary>
      <pre id="raw">—</pre>
    </details>

    <details style="margin-top:10px;">
      <summary>Debug: transaction object</summary>
      <pre id="txdebug">—</pre>
    </details>
  </div>

  <script type="module">
    import { createClient } from "https://esm.sh/genlayer-js";
    import { studionet } from "https://esm.sh/genlayer-js/chains";
    import { TransactionStatus } from "https://esm.sh/genlayer-js/types";

    // === SET THIS ===
    const CONTRACT_ADDRESS = "0x44377D8Cdc8867121bC174a8E81A4A243Bb2eeB6";

    // Studio RPC
    const RPC_ENDPOINT = "https://studio.genlayer.com/api";

    const el = (id) => document.getElementById(id);
    const setStatus = (s) => el("status").textContent = s;

    let account = null;
    let client = null;

    // --- Provider shim: implements eth_fillTransaction locally if missing ---
    function wrapProvider(provider) {
      return {
        ...provider,
        request: async ({ method, params }) => {
          if (method === "eth_fillTransaction") {
            // params[0] is an unsigned tx object. Fill nonce/gas/gasPrice if missing.
            const tx = { ...(params?.[0] || {}) };

            // ensure from
            if (!tx.from) {
              const accs = await provider.request({ method: "eth_accounts", params: [] });
              tx.from = accs?.[0];
            }

            // nonce
            if (tx.nonce == null) {
              const nonce = await provider.request({
                method: "eth_getTransactionCount",
                params: [tx.from, "pending"]
              });
              tx.nonce = nonce;
            }

            // gas
            if (tx.gas == null) {
              try {
                const gas = await provider.request({
                  method: "eth_estimateGas",
                  params: [tx]
                });
                tx.gas = gas;
              } catch {
                // fallback: leave it; MetaMask may still handle
              }
            }

            // gas price (legacy) if EIP-1559 fields are missing
            if (tx.gasPrice == null && tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
              try {
                const gp = await provider.request({ method: "eth_gasPrice", params: [] });
                tx.gasPrice = gp;
              } catch {
                // ignore
              }
            }

            return tx;
          }

          return provider.request({ method, params });
        }
      };
    }

    async function refreshChain() {
      try {
        const chainId = await window.ethereum.request({ method: "eth_chainId" });
        el("chain").textContent = `Chain: ${chainId}`;
      } catch {
        el("chain").textContent = "Chain: —";
      }
    }

    async function ensureClient() {
      if (!account) throw new Error("Connect MetaMask first.");
      if (!client) {
        // IMPORTANT:
        // Docs: passing address string enables external signing (MetaMask). :contentReference[oaicite:3]{index=3}
        client = createClient({
          chain: studionet,
          endpoint: RPC_ENDPOINT,
          account: account
        });
        await client.initializeConsensusSmartContract();
      }
      return client;
    }

    function render(raw, txHash = "") {
      el("out").style.display = "block";
      el("raw").textContent = raw || "—";
      el("txline").textContent = txHash ? `tx: ${txHash}` : "—";

      try {
        const obj = JSON.parse(raw);

        el("verdict").textContent = `Verdict: ${obj.verdict ?? "—"}`;
        el("explanation").textContent = obj.explanation ?? "—";

        const sources = Array.isArray(obj.sources) ? obj.sources : [];
        el("sources").innerHTML = sources.length
          ? "<ul>" + sources.map(s => {
              const u = (s && s.url) ? s.url : "";
              const note = (s && s.note) ? s.note : "";
              const safeU = u.replaceAll('"', "&quot;");
              return `<li><a href="${safeU}" target="_blank" rel="noreferrer">${u}</a> <span class="muted">— ${note}</span></li>`;
            }).join("") + "</ul>"
          : "(no sources)";

        const claims = Array.isArray(obj.key_claims) ? obj.key_claims : [];
        el("claims").innerHTML = claims.length
          ? "<ol>" + claims.map(c => `<li>${String(c)}</li>`).join("") + "</ol>"
          : "(no claims)";
      } catch {
        el("verdict").textContent = "Verdict: Parse error";
        el("explanation").textContent = "Contract output is not valid JSON. See Raw JSON.";
        el("sources").textContent = "—";
        el("claims").textContent = "—";
      }
    }

    el("btnConnect").onclick = async () => {
      if (!window.ethereum) return alert("MetaMask is required.");

      // install shim BEFORE anything else touches provider
      window.ethereum = wrapProvider(window.ethereum);

      const accs = await window.ethereum.request({ method: "eth_requestAccounts", params: [] });
      account = accs?.[0] || null;
      el("wallet").textContent = account || "Not connected";

      client = null;
      await refreshChain();
      await ensureClient();

      setStatus("Connected.");
    };

    el("btnVerify").onclick = async () => {
      const url = el("url").value.trim();
      if (!url.startsWith("http://") && !url.startsWith("https://")) {
        return alert("Please enter a valid http/https URL.");
      }
      setStatus("Submitting verify(url)…");
      const c = await ensureClient();

      try {
        const txHash = await c.writeContract({
          address: CONTRACT_ADDRESS,
          functionName: "verify",
          args: [url],
          value: 0n
        });

        el("txhash").value = txHash;

        // Wait for FINALIZED for stable read :contentReference[oaicite:4]{index=4}
        setStatus("Waiting for FINALIZED…");
        await c.waitForTransactionReceipt({
          hash: txHash,
          status: TransactionStatus.FINALIZED,
          retries: 200,
          interval: 3000
        });

        setStatus("FINALIZED. Reading get(url)…");
        const res = await c.readContract({
          address: CONTRACT_ADDRESS,
          functionName: "get",
          args: [url]
        });

        // If key mismatch, fallback to get_last
        if (!res || String(res).trim() === "") {
          const last = await c.readContract({
            address: CONTRACT_ADDRESS,
            functionName: "get_last",
            args: []
          });
          const lastRaw = last?.result || "";
          render(lastRaw, txHash);
        } else {
          render(res, txHash);
        }

        // Debug tx object
        try {
          const txObj = await c.getTransaction({ hash: txHash });
          el("txdebug").textContent = JSON.stringify(txObj, null, 2);
        } catch {}

        setStatus("Done.");
      } catch (e) {
        console.error(e);
        setStatus("Error: " + (e?.message || String(e)));
      }
    };

    el("btnGet").onclick = async () => {
      const url = el("url").value.trim();
      if (!url) return;
      setStatus("Reading get(url)…");
      try {
        const c = await ensureClient();
        const res = await c.readContract({
          address: CONTRACT_ADDRESS,
          functionName: "get",
          args: [url]
        });
        render(res || "");
        setStatus("Done.");
      } catch (e) {
        console.error(e);
        setStatus("Error: " + (e?.message || String(e)));
      }
    };

    el("btnLast").onclick = async () => {
      setStatus("Reading get_last()…");
      try {
        const c = await ensureClient();
        const last = await c.readContract({
          address: CONTRACT_ADDRESS,
          functionName: "get_last",
          args: []
        });
        const raw = last?.result || "";
        render(raw || "");
        setStatus("Done.");
      } catch (e) {
        console.error(e);
        setStatus("Error: " + (e?.message || String(e)));
      }
    };

    try { await refreshChain(); } catch {}
  </script>
</body>
</html>
